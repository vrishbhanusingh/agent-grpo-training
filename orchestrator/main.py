## Generated by Copilot
"""
Orchestrator CLI for testing agentic workflow communication.
Sends a test task to the small model agent, waits for response and reward, and prints results.
"""
import argparse
import json
import os
import sys
import time
from typing import Any, Dict
import pika

TASK_QUEUE = 'task_queue'
RESPONSE_QUEUE = 'response_queue'
REWARD_QUEUE = 'reward_queue'

RABBITMQ_HOST = os.environ.get('RABBITMQ_HOST', 'rabbitmq')  # Use 'rabbitmq' for Docker
RABBITMQ_USER = os.environ.get('RABBITMQ_USER', 'user')
RABBITMQ_PASS = os.environ.get('RABBITMQ_PASS', 'password')


def send_task_and_get_result(task_input: str, timeout: float = 10.0) -> None:
    """
    Send a test task to the small model agent and print the response and reward.
    Args:
        task_input: The input string for the task.
        timeout: How long to wait for responses (seconds).
    Raises:
        RuntimeError: If no response or reward is received in time.
    """
    credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, credentials=credentials))
    channel = connection.channel()
    # Ensure queues exist
    channel.queue_declare(queue=TASK_QUEUE, durable=True)
    channel.queue_declare(queue=RESPONSE_QUEUE, durable=True)
    channel.queue_declare(queue=REWARD_QUEUE, durable=True)

    task_id = f"test-{int(time.time())}"
    task_msg = {
        "task_id": task_id,
        "input": task_input,
        "metadata": {"timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ'), "source": "cli"}
    }
    channel.basic_publish(
        exchange='', routing_key=TASK_QUEUE, body=json.dumps(task_msg),
        properties=pika.BasicProperties(delivery_mode=2)
    )
    print(f"[Orchestrator] Sent task: {task_msg}")

    response = None
    reward = None
    start = time.time()
    # Wait for response
    while time.time() - start < timeout:
        method, props, body = channel.basic_get(RESPONSE_QUEUE, auto_ack=True)
        if body:
            msg = json.loads(body)
            if msg.get('task_id') == task_id:
                response = msg
                print(f"[Orchestrator] Got response: {response}")
                break
        time.sleep(0.2)
    if not response:
        raise RuntimeError("No response received from small model agent.")
    # Wait for reward
    start = time.time()
    while time.time() - start < timeout:
        method, props, body = channel.basic_get(REWARD_QUEUE, auto_ack=True)
        if body:
            msg = json.loads(body)
            if msg.get('task_id') == task_id:
                reward = msg
                print(f"[Orchestrator] Got reward: {reward}")
                break
        time.sleep(0.2)
    if not reward:
        raise RuntimeError("No reward received from scoring agent.")
    print("[Orchestrator] Test complete.")
    connection.close()


def main() -> None:
    """
    CLI entry point for orchestrator testing.
    """
    parser = argparse.ArgumentParser(description="Orchestrator CLI for agentic workflow test.")
    parser.add_argument('--test', action='store_true', help='Send a test task and print results')
    parser.add_argument('--input', type=str, default='What is the capital of France?', help='Task input string')
    args = parser.parse_args()
    if args.test:
        try:
            send_task_and_get_result(args.input)
        except Exception as e:
            print(f"[Orchestrator] Error: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
## End of generated code
