## Generated by Copilot
"""
Isolated RabbitMQ Test Runner

This script automates the process of reliably testing the agentic workflow by:
1. Stopping the orchestrator to prevent interference.
2. Clearing the task_queue and response_queue using the RabbitMQ management API.
3. Running the test_rabbitmq_communication.py script.
4. Restarting the orchestrator after the test.

Requirements:
- requests Python package (for RabbitMQ HTTP API)
- Docker and docker-compose installed
- RabbitMQ management plugin enabled (default in your setup)

Usage:
    python isolated_rabbitmq_test.py

Exceptions:
    Raises RuntimeError on any failure step.
"""
import subprocess
import requests
import sys
import time
from typing import Any

RABBITMQ_API = "http://localhost:15672/api/queues/%2F"
RABBITMQ_USER = "user"
RABBITMQ_PASS = "password"
QUEUES = ["task_queue", "response_queue"]

def stop_orchestrator() -> None:
    """Stop the orchestrator service using docker-compose."""
    result = subprocess.run(["docker-compose", "stop", "orchestrator"], capture_output=True)
    assert result.returncode == 0, f"Failed to stop orchestrator: {result.stderr.decode()}"
    print("[Copilot] Orchestrator stopped.")

def start_orchestrator() -> None:
    """Start the orchestrator service using docker-compose."""
    result = subprocess.run(["docker-compose", "start", "orchestrator"], capture_output=True)
    assert result.returncode == 0, f"Failed to start orchestrator: {result.stderr.decode()}"
    print("[Copilot] Orchestrator started.")

def purge_queue(queue: str) -> None:
    """Purge a RabbitMQ queue using the management HTTP API."""
    url = f"{RABBITMQ_API}/{queue}/contents"
    resp = requests.delete(url, auth=(RABBITMQ_USER, RABBITMQ_PASS))
    assert resp.status_code in (204, 200), f"Failed to purge {queue}: {resp.text}"
    print(f"[Copilot] Purged queue: {queue}")

def run_test_script() -> None:
    """Run the test_rabbitmq_communication.py script and print all output verbosely."""
    try:
        result = subprocess.run(["poetry", "run", "python", "test_rabbitmq_communication.py"], capture_output=True)
    except FileNotFoundError:
        result = subprocess.run(["python3", "test_rabbitmq_communication.py"], capture_output=True)
    print("[Copilot] Test script STDOUT:")
    print(result.stdout.decode())
    print("[Copilot] Test script STDERR:", file=sys.stderr)
    print(result.stderr.decode(), file=sys.stderr)
    assert result.returncode == 0, "Test script failed. See output above."
    print("[Copilot] Test script completed successfully.")

def main() -> None:
    """Main entry point for isolated RabbitMQ test runner with verbose output."""
    print("[Copilot] Stopping orchestrator...")
    stop_orchestrator()
    time.sleep(2)
    for queue in QUEUES:
        print(f"[Copilot] Purging queue: {queue} ...")
        purge_queue(queue)
    time.sleep(2)
    print("[Copilot] Running test script...")
    run_test_script()
    print("[Copilot] Restarting orchestrator...")
    start_orchestrator()
    print("[Copilot] Isolated RabbitMQ test completed.")

if __name__ == "__main__":
    main()
## End of generated code
