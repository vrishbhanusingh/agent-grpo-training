## Generated by Copilot
"""
Orchestrator CLI for testing agentic workflow communication.
Sends a test task to the small model agent, waits for response and reward, and prints results.
"""
import argparse
import json
import os
import sys
import time
import uuid
from typing import Any, Dict, NoReturn
import pika

TASK_QUEUE = 'task_queue'
RESPONSE_QUEUE = 'response_queue'
REWARD_QUEUE = 'reward_queue'

RABBITMQ_HOST = os.environ.get('RABBITMQ_HOST', 'rabbitmq')  # Use 'rabbitmq' for Docker
RABBITMQ_USER = os.environ.get('RABBITMQ_USER', 'user')
RABBITMQ_PASS = os.environ.get('RABBITMQ_PASS', 'password')


def send_task_and_get_result(task_input: str, timeout: float = 10.0) -> None:
    """
    Send a test task to the small model agent and print the response and reward.
    Args:
        task_input: The input string for the task.
        timeout: How long to wait for responses (seconds).
    Raises:
        RuntimeError: If no response or reward is received in time.
    """
    credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, credentials=credentials))
    channel = connection.channel()
    # Ensure queues exist
    channel.queue_declare(queue=TASK_QUEUE, durable=True)
    channel.queue_declare(queue=RESPONSE_QUEUE, durable=True)
    channel.queue_declare(queue=REWARD_QUEUE, durable=True)

    task_id = f"test-{int(time.time())}"
    task_msg = {
        "task_id": task_id,
        "input": task_input,
        "metadata": {"timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ'), "source": "cli"}
    }
    channel.basic_publish(
        exchange='', routing_key=TASK_QUEUE, body=json.dumps(task_msg),
        properties=pika.BasicProperties(delivery_mode=2)
    )
    print(f"[Orchestrator] Sent task: {task_msg}")

    response = None
    reward = None
    start = time.time()
    # Wait for response
    while time.time() - start < timeout:
        method, props, body = channel.basic_get(RESPONSE_QUEUE, auto_ack=True)
        if body:
            msg = json.loads(body)
            if msg.get('task_id') == task_id:
                response = msg
                print(f"[Orchestrator] Got response: {response}")
                break
        time.sleep(0.2)
    if not response:
        raise RuntimeError("No response received from small model agent.")
    # Wait for reward
    start = time.time()
    while time.time() - start < timeout:
        method, props, body = channel.basic_get(REWARD_QUEUE, auto_ack=True)
        if body:
            msg = json.loads(body)
            if msg.get('task_id') == task_id:
                reward = msg
                print(f"[Orchestrator] Got reward: {reward}")
                break
        time.sleep(0.2)
    if not reward:
        raise RuntimeError("No reward received from scoring agent.")
    print("[Orchestrator] Test complete.")
    connection.close()


def persistent_task_sender() -> NoReturn:
    """
    Continuously sends a dummy task message to the small model agent every 10 seconds.
    Handles connection errors and retries indefinitely.
    Each message includes a unique task_id and ISO timestamp.
    Raises:
        Never returns; logs and recovers from all exceptions.
    Usage:
        Called as the main entrypoint for persistent orchestrator mode.
    """
    credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
    while True:
        try:
            connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, credentials=credentials))
            channel = connection.channel()
            channel.queue_declare(queue=TASK_QUEUE, durable=True)
            while True:
                task_id = str(uuid.uuid4())
                task_msg = {
                    "task_id": task_id,
                    "input": "Dummy message from orchestrator",
                    "metadata": {"timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ'), "source": "persistent_orchestrator"}
                }
                channel.basic_publish(
                    exchange='', routing_key=TASK_QUEUE, body=json.dumps(task_msg),
                    properties=pika.BasicProperties(delivery_mode=2)
                )
                print(f"[Orchestrator] Sent dummy task: {task_msg}")
                assert isinstance(task_msg["task_id"], str) and task_msg["task_id"], "task_id must be a non-empty string"
                time.sleep(10)
        except pika.exceptions.AMQPConnectionError as e:
            print(f"[Orchestrator][ERROR] RabbitMQ connection error: {e}. Retrying in 5 seconds...")
            time.sleep(5)
        except Exception as e:
            print(f"[Orchestrator][ERROR] Unexpected error: {e}. Retrying in 5 seconds...")
            time.sleep(5)


def main() -> None:
    """
    CLI entry point for orchestrator testing or persistent mode.
    """
    parser = argparse.ArgumentParser(description="Orchestrator CLI for agentic workflow test.")
    parser.add_argument('--test', action='store_true', help='Send a test task and print results')
    parser.add_argument('--input', type=str, default='What is the capital of France?', help='Task input string')
    parser.add_argument('--persistent', action='store_true', help='Run orchestrator in persistent mode (send dummy tasks every 10s)')
    args = parser.parse_args()
    if args.test:
        try:
            send_task_and_get_result(args.input)
        except Exception as e:
            print(f"[Orchestrator] Error: {e}", file=sys.stderr)
            sys.exit(1)
    elif args.persistent:
        persistent_task_sender()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
## End of generated code
