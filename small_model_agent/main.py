## Generated by Copilot
"""
Small Model Agent: Listens for tasks on RabbitMQ, generates a mock response, and sends it to the response queue.
Includes robust connection retry and startup logging.
"""
import json
import os
import time
from typing import Any, Dict
import pika

TASK_QUEUE = 'task_queue'
RESPONSE_QUEUE = 'response_queue'

RABBITMQ_HOST = os.environ.get('RABBITMQ_HOST', 'rabbitmq')  # Use 'rabbitmq' for Docker
RABBITMQ_USER = os.environ.get('RABBITMQ_USER', 'user')
RABBITMQ_PASS = os.environ.get('RABBITMQ_PASS', 'password')
AGENT_ID = 'small_model_1'


def connect_with_retry(max_retries: int = 10, delay: float = 2.0) -> pika.BlockingConnection:
    """
    Attempt to connect to RabbitMQ with retries.
    Raises RuntimeError if connection fails after max_retries.
    """
    for attempt in range(1, max_retries + 1):
        try:
            print(f"[SmallModelAgent] Connecting to RabbitMQ (attempt {attempt})...")
            credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
            connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, credentials=credentials))
            print("[SmallModelAgent] Connected to RabbitMQ.")
            return connection
        except Exception as e:
            print(f"[SmallModelAgent] Connection failed: {e}")
            time.sleep(delay)
    raise RuntimeError("[SmallModelAgent] Could not connect to RabbitMQ after retries.")

def main() -> None:
    """
    Main loop for the small model agent. Listens for tasks and sends mock responses.
    """
    try:
        connection = connect_with_retry()
        channel = connection.channel()
        channel.queue_declare(queue=TASK_QUEUE, durable=True)
        channel.queue_declare(queue=RESPONSE_QUEUE, durable=True)
        print("[SmallModelAgent] Waiting for tasks...")
        def callback(ch, method, properties, body):
            task = json.loads(body)
            print(f"[SmallModelAgent] Received task: {task}")
            response = {
                "task_id": task["task_id"],
                "response": f"Mock answer to: {task['input']}",
                "agent_id": AGENT_ID,
                "metadata": {"timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ')}
            }
            channel.basic_publish(
                exchange='', routing_key=RESPONSE_QUEUE, body=json.dumps(response),
                properties=pika.BasicProperties(delivery_mode=2)
            )
            print(f"[SmallModelAgent] Sent response: {response}")
            ch.basic_ack(delivery_tag=method.delivery_tag)
        channel.basic_qos(prefetch_count=1)
        channel.basic_consume(queue=TASK_QUEUE, on_message_callback=callback)
        channel.start_consuming()
    except Exception as e:
        print(f"[SmallModelAgent] Fatal error: {e}")
        time.sleep(5)
        raise

if __name__ == "__main__":
    main()
## End of generated code
