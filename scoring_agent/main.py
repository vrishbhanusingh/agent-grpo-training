## Generated by Copilot
"""
Scoring Agent: Listens for responses on RabbitMQ, generates a mock reward, and sends it to the reward queue.
Includes robust connection retry and startup logging.
"""
import json
import os
import time
from typing import Any, Dict
import pika

RESPONSE_QUEUE = 'response_queue'
REWARD_QUEUE = 'reward_queue'

RABBITMQ_HOST = os.environ.get('RABBITMQ_HOST', 'rabbitmq')  # Use 'rabbitmq' for Docker
RABBITMQ_USER = os.environ.get('RABBITMQ_USER', 'user')
RABBITMQ_PASS = os.environ.get('RABBITMQ_PASS', 'password')
SCORING_AGENT_ID = 'scoring_agent_1'

def connect_with_retry(max_retries: int = 10, delay: float = 2.0) -> pika.BlockingConnection:
    """
    Attempt to connect to RabbitMQ with retries.
    Raises RuntimeError if connection fails after max_retries.
    """
    for attempt in range(1, max_retries + 1):
        try:
            print(f"[ScoringAgent] Connecting to RabbitMQ (attempt {attempt})...")
            credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
            connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, credentials=credentials))
            print("[ScoringAgent] Connected to RabbitMQ.")
            return connection
        except Exception as e:
            print(f"[ScoringAgent] Connection failed: {e}")
            time.sleep(delay)
    raise RuntimeError("[ScoringAgent] Could not connect to RabbitMQ after retries.")

def main() -> None:
    """
    Main loop for the scoring agent. Listens for responses and sends mock rewards.
    """
    try:
        connection = connect_with_retry()
        channel = connection.channel()
        channel.queue_declare(queue=RESPONSE_QUEUE, durable=True)
        channel.queue_declare(queue=REWARD_QUEUE, durable=True)
        print("[ScoringAgent] Waiting for responses...")
        def callback(ch, method, properties, body):
            response = json.loads(body)
            print(f"[ScoringAgent] Received response: {response}")
            reward = {
                "task_id": response["task_id"],
                "score": 0.95,  # Mock score
                "scoring_agent_id": SCORING_AGENT_ID,
                "metadata": {"timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ'), "criteria": "mock"}
            }
            channel.basic_publish(
                exchange='', routing_key=REWARD_QUEUE, body=json.dumps(reward),
                properties=pika.BasicProperties(delivery_mode=2)
            )
            print(f"[ScoringAgent] Sent reward: {reward}")
            ch.basic_ack(delivery_tag=method.delivery_tag)
        channel.basic_qos(prefetch_count=1)
        channel.basic_consume(queue=RESPONSE_QUEUE, on_message_callback=callback)
        channel.start_consuming()
    except Exception as e:
        print(f"[ScoringAgent] Fatal error: {e}")
        time.sleep(5)
        raise

if __name__ == "__main__":
    main()
## End of generated code
