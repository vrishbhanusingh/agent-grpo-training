## Generated by Copilot
"""
test_rabbitmq_communication.py

A script to test RabbitMQ communication for the agentic workflow project.
- Publishes a test task message to the Task Queue.
- Listens for a response on the Response Queue.
- Listens for a reward on the Reward Queue.

Requirements:
- RabbitMQ running and accessible
- pika Python package installed

Usage:
    python test_rabbitmq_communication.py

Author: Copilot
Date: 2025-04-20
"""
import json
import time
import uuid
from typing import Any, Dict, Optional
import pika
import sys

# Constants for queue names
TASK_QUEUE: str = 'TaskQ'
RESPONSE_QUEUE: str = 'ResponseQ'
REWARD_QUEUE: str = 'RewardQ'
RABBITMQ_HOST: str = 'localhost'
RABBITMQ_PORT: int = 5672


def print_verbose(msg: str) -> None:
    """
    Print a verbose message to stdout.
    Args:
        msg: The message to print.
    """
    print(f"[Copilot][DEBUG] {msg}")


def publish_task_message(task_id: str, input_text: str) -> None:
    """
    Publish a test task message to the Task Queue.
    Args:
        task_id: Unique identifier for the task.
        input_text: The input prompt or data for the agent.
    Raises:
        pika.exceptions.AMQPError: If publishing fails.
    """
    message: Dict[str, Any] = {
        "task_id": task_id,
        "input": input_text,
        "metadata": {
            "timestamp": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            "source": "test_script"
        }
    }
    try:
        connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, port=RABBITMQ_PORT))
        channel = connection.channel()
        channel.queue_declare(queue=TASK_QUEUE, durable=True)
        channel.basic_publish(
            exchange='',
            routing_key=TASK_QUEUE,
            body=json.dumps(message),
            properties=pika.BasicProperties(delivery_mode=2)
        )
        print_verbose(f"Sent task message: {message}")
        connection.close()
    except pika.exceptions.AMQPConnectionError as e:
        print(f"[Copilot][ERROR] Could not connect to RabbitMQ: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[Copilot][ERROR] Unexpected error in publish_task_message: {e}")
        sys.exit(1)


def consume_message(queue: str, filter_task_id: str, timeout: int = 10) -> Optional[Dict[str, Any]]:
    """
    Consume a message from a queue, filtering by task_id.
    Args:
        queue: The queue name to consume from.
        filter_task_id: The task_id to filter for.
        timeout: Timeout in seconds to wait for a message.
    Returns:
        The message dict if found, else None.
    Raises:
        pika.exceptions.AMQPError: If connection fails.
    """
    try:
        connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST, port=RABBITMQ_PORT))
        channel = connection.channel()
        channel.queue_declare(queue=queue, durable=True)
        method_frame, header_frame, body = None, None, None
        start_time = time.time()
        while time.time() - start_time < timeout:
            method_frame, header_frame, body = channel.basic_get(queue=queue, auto_ack=True)
            if method_frame:
                try:
                    message = json.loads(body)
                    assert isinstance(message, dict), "Message is not a dict"
                    if message.get("task_id") == filter_task_id:
                        print_verbose(f"Received from {queue}: {message}")
                        connection.close()
                        return message
                    else:
                        print_verbose(f"Skipped unrelated message in {queue}: {message}")
                except Exception as e:
                    print(f"[Copilot][ERROR] Error decoding message from {queue}: {e}")
            time.sleep(1)
        print(f"[Copilot][WARN] No message received from {queue} for task_id {filter_task_id} within timeout.")
        connection.close()
        return None
    except pika.exceptions.AMQPConnectionError as e:
        print(f"[Copilot][ERROR] Could not connect to RabbitMQ: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[Copilot][ERROR] Unexpected error in consume_message: {e}")
        sys.exit(1)


def main() -> None:
    """
    Main function to test RabbitMQ communication.
    Steps:
    1. Publish a test task message.
    2. Wait for a response message.
    3. Wait for a reward message.
    """
    task_id: str = str(uuid.uuid4())
    input_text: str = "What is the capital of France?"
    try:
        print_verbose("Publishing test task message...")
        publish_task_message(task_id, input_text)
        print("[Copilot] Waiting for response message...")
        response = consume_message(RESPONSE_QUEUE, task_id)
        assert response is not None, "No response message received. Check if small_model_agent is running and connected."
        print("[Copilot] Waiting for reward message...")
        reward = consume_message(REWARD_QUEUE, task_id)
        assert reward is not None, "No reward message received. Check if scoring_agent is running and connected."
        print("[Copilot][SUCCESS] Communication test successful.")
    except AssertionError as ae:
        print(f"[Copilot][FAIL] Assertion failed: {ae}")
        sys.exit(2)
    except Exception as e:
        print(f"[Copilot][ERROR] Unexpected error in main: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
## End of generated code
